import numpy as np
from sklearn.cluster import KMeans
from rtree import index
import pickle
from tqdm import tqdm
import geoql, geojson
from copy import deepcopy
import networkx as nx

# Want a function that takes as input 
# set of geojson points, set of geojson linestrings

# points is a list of (x, y) coordinates
# linestrings is a list of geojson linestrings representing streets

def project(p1, l1, l2):
    # find projection of p1 onto line between l1 and l2
    p1 = np.array(p1)
    l1 = np.array(l1)
    l2 = np.array(l2)

    line = l2 - l1
    vec = p1 - l1
    #print(l1, l2, vec, line, line.dot(line), flush=True)
    return l1 + (vec.dot(line) / line.dot(line)) * line  # Projects vec onto line

def normal(p1, l1, l2):
    p1 = np.array(p1)
    l1 = np.array(l1)
    l2 = np.array(l2)

    proj = project_point_to_segment(p1, l1, l2)
    return proj - p1

def project_point_to_segment(p1, l1, l2):
    p1 = np.array(p1)
    l1 = np.array(l1)
    l2 = np.array(l2)

    proj = project(p1, l1, l2)
    v1 = proj - l1
    v2 = proj - l2

    # v1 and v2 face in opposite directions if the dot product is negative 
    if v1.dot(v2) <= 0:
        return proj
    elif np.dot(v1, v1) <= np.dot(v2, v2): # proj not on segment
        return l1
    else: # distance from point to l2 is smaller
        return l2

def rTreeify(obj):
    '''takes geojson FeatureCollection of linestrings and constructs rTree'''
    tree = index.Index()
    tree_keys = {}
    i = 0
    for j, lstr in enumerate(obj.features):
        for p in lstr.geometry.coordinates:
            tree_keys[str(i)] = j
            x, y = p[0], p[1]
            tree.insert(i,(x,y,x,y))
            i += 1

    return tree, tree_keys

def find_intersection(obj, tree, tree_keys, p, r):
    ''' Finds all points in the rtree tree in the bounding box centered on p with
        radius r '''
    lat, lon = p
    result = set()
    for i in tqdm(list(tree.intersection((lat-r, lon-r, lat+r, lon+r)))):
        result.add(tree_keys[str(i)])

    result = list(result)
    result.sort()
    obj.features = [obj.features[j] for j in result]

    return obj

# UNFINISHED
def project_points_to_linestrings(points, linestrings):
    # Todo: Implement rtrees to find line points within certain distance

    projections = []
    tree, tree_keys = rTreeify(linestrings)

    for lat,lon in tqdm(points):
        p = np.array([lat, lon])
        lstr_copy = deepcopy(linestrings)
        lstr_copy = find_intersection(lstr_copy, tree, tree_keys, p, 0.01)
        lstr_copy = geoql.features_keep_within_radius(lstr_copy, [lon,lat], 0.5, 'miles')
        min_proj = (10000, [0,0])
        for lstr in lstr_copy.features:
            segments = lstr.geometry.coordinates
            for i in range(len(segments)-1):
                if np.linalg.norm(np.array(segments[i+1]) - np.array(segments[i])) == 0:
                    continue
                norm = normal(p, segments[i], segments[i+1])
                dist = norm.dot(norm)
                if dist < min_proj[0]:
                    proj = project_point_to_segment(p, segments[i], segments[i+1])
                    min_proj = [dist, proj, np.array(segments[i]), np.array(segments[i+1])]
        projections.append(min_proj)

    return [p[1:] for p in projections]

def load_road_segments(fname):
    linestrings = geojson.loads(open(fname, 'r').read())
    linestrings.features = [seg for seg in linestrings.features if seg.type=='Feature']
    return linestrings

def to_networkx(graph_ql):
    ''' Creates and returns a geojson graph generated by the geoql function node_edge_graph into a networkx representation'''
    G = nx.Graph()
    for j, feature in enumerate(graph_ql.features):
        if feature.type == "Point":
            G.add_node(tuple(feature.coordinates))
        elif feature.type == "Feature":
            coords = [tuple(c) for c in feature.geometry.coordinates]

            for i in range(len(coords)-1):
                G.add_edge(coords[i], coords[i+1], index=j)
    return G

def find_connected_segment_indices(obj):
    G = to_networkx(obj)
    G = nx.subgraph(G, max(nx.connected_components(G), key=lambda x:len(x)))
    indices = set()
    for v0, v1 in G.edges():
        indices.add(G[v0][v1]['index'])

    obj.features = [obj.features[i] for i in indices]
    return obj

def generate_student_stops(student_features, numStops=5000, loadFrom=None):
    # We assume that the order of stops will not change at any point

    # We don't want to do anything to d2d stops
    d2d_stops = [f['geometry']['coordinates'][0]
       for f in student_features['features']
       if f['properties']['pickup'] == 'd2d']

    # get means from pickle or generate
    if loadFrom:
        k_fit = pickle.load(open(loadFrom, 'rb'))
        corner_stops = k_fit['corner_stops']
        labels = k_fit['labels']
    else:
        # load student coordinates from students datafile to list of coordinates
        corner_students = [feature['geometry']['coordinates'][0]
                  for feature in student_features['features']
                  if feature['properties']['pickup'] == 'corner']
    
        #generate means for corner students
        kmeans = KMeans(n_clusters=numStops, random_state=0)
        k_fit = kmeans.fit(corner_students)
        corner_stops = k_fit.cluster_centers_
        labels = k_fit.labels_

        # Write kmeans results to a file
        with open('kmeans', 'w') as f:
            f.write(pickle.dumps({'means': means, 'corner_stops': labels}))

    # get linestrings from roadsegments
    linestrings = load_road_segments('input_data/example_extract_missing.geojson')
    linestrings = find_connected_segment_indices(linestrings)
    
    projected_corner_stops = project_points_to_linestrings(corner_stops, linestrings)

    all_stops = []
    for feature in range(student_features['features']):
        if feature['properties']['pickup'] == 'd2d':
            all_stops.append(d2d_stops)
        else: # pickup type is corner student
            all_stops.append(projected_corner_stops)

    return all_stops

def run():
    import time
    
    student_features = geojson.loads(open('input_data/students.geojson', 'r').read())

    start = time.time()
    stops = generate_student_stops(student_features)#, loadFrom='input_data/kmeans')
    end = time.time()

    with open('output/timelog', 'w') as f:
        f.write(str(end-start))

    with open('output/stops', 'wb') as f:
        f.write(pickle.dumps(stops))

#run()




